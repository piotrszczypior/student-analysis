% \clearpage
% \section{Testy}

% \subsection{DeleteOldRentals}
% Scenariusz \textit{DeleteOldRentals} polega na usunięciu rekordów wypożyczeń starszych niż dwa lata względem bieżącej daty. W przypadku ORM wykorzystano Entity Framework Core z metodą \texttt{RemoveRange}, natomiast w wersji SQL zastosowano bezpośrednie zapytanie \texttt{DELETE} z parametrem daty granicznej.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{DeleteOldRentals}}

% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 4.56 & 4.24 \\
% 2 & 7.09 & 3.74 \\
% 3 & 7.60 & 4.17 \\
% 4 & 7.46 & 3.98 \\
% 5 & 7.75 & 4.31 \\
% 6 & 7.45 & 4.33 \\
% 7 & 7.55 & 4.25 \\
% 8 & 7.43 & 4.28 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 7.20 & 4.17 \\
% Odchylenie & 1.01 & 0.19 \\
% Min & 4.56 & 3.74 \\
% Max & 7.88 & 4.33 \\
% Zaalokowane bajty na operacje & 58856 & 9744 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- usunięcie wypożyczeń starszych niż zadana data}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% DELETE FROM "Rentals"
% WHERE "RentalStart" < @CutoffDate
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% DELETE FROM "Rentals"
%       WHERE "Id" = @p0;
% \end{minted}
% \end{listing}

% \subsection{InsertActorBenchmark}
% Scenariusz \textit{InsertActorBenchmark} mierzy czas wykonania pojedynczej operacji wstawiania nowego aktora do tabeli \texttt{Actors}. W podejściu ORM wykorzystano Entity Framework Core z metodą \texttt{Add}, natomiast w wersji SQL zastosowano ręczne zapytanie \texttt{INSERT INTO} z parametrami przekazywanymi do zapytania przy pomocy Dappera.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{InsertActorBenchmark}}

% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 2.60 & 1.03 \\
% 2 & 2.52 & 0.96 \\
% 3 & 2.45 & 0.98 \\
% 4 & 2.65 & 1.00 \\
% 5 & 2.62 & 1.02 \\
% 6 & 2.62 & 1.06 \\
% 7 & 2.78 & 1.06 \\
% 8 & 2.72 & 1.02 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 2.64 & 1.02 \\
% Odchylenie & 0.11 & 0.04 \\
% Min & 2.45 & 0.96 \\
% Max & 2.79 & 1.06 \\
% Zaalokowane bajty na operacje & 83016 & 9824 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- dodanie nowego aktora}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% INSERT INTO "Actors" ("FirstName", "LastName", "LastUpdate")
% VALUES (@FirstName, @LastName, @LastUpdate)
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% INSERT INTO "Actors" ("FirstName", "LastName", "LastUpdate")
%       VALUES (@p0, @p1, @p2)
%       RETURNING "Id";
% \end{minted}
% \end{listing}

% \subsection{SelectActionFilms}
% Scenariusz \textit{SelectActionFilms} polega na pobraniu wszystkich filmów należących do kategorii \texttt{Action}. W wersji ORM wykorzystano zapytanie LINQ z filtrowaniem po kolekcji kategorii filmów, natomiast podejście SQL bazuje na jawnych złączeniach tabel \texttt{Films}, \texttt{FilmsCategories} oraz \texttt{Categories} przy użyciu instrukcji \texttt{JOIN}.

% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectActionFilms}}

% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 3.03 & 3.34 \\
% 2 & 2.99 & 2.80 \\
% 3 & 3.00 & 2.47 \\
% 4 & 2.96 & 2.69 \\
% 5 & 3.17 & 2.69 \\
% 6 & 3.74 & 2.82 \\
% 7 & 3.60 & 2.17 \\
% 8 & 3.46 & 2.44 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 3.24 & 2.60 \\
% Odchylenie & 0.31 & 0.35 \\
% Min & 2.96 & 2.17 \\
% Max & 3.74 & 3.34 \\
% Zaalokowane bajty na operacje & 63624 & 47400 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- filmy z kategorii 'Action'}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT DISTINCT f.*
% FROM "Films" f
% JOIN "FilmsCategories" fc ON f."Id" = fc."FilmId"
% JOIN "Categories" c ON fc."CategoryId" = c."Id"
% WHERE c."Name" = 'Action'
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT f."Id", f."Description", f."FullText", f."LanguageId", f."LastUpdate", f."Length",
%        f."OriginalLanguageId", f."Rating", f."ReleaseYear", f."RentalDuration", f."RentalRate",
%        f."ReplacementCost", f."RevenueProjection", f."SpecialFeatures", f."Title"
% FROM "Films" AS f
% WHERE EXISTS (
%     SELECT 1
%     FROM "FilmsCategories" AS f0
%     INNER JOIN "Categories" AS c ON f0."CategoryId" = c."Id"
%     WHERE f."Id" = f0."FilmId" AND c."Name" = 'Action'
% )
% \end{minted}
% \end{listing}

% \subsection{SelectActiveCustomersByStore}
% Scenariusz \textit{SelectActiveCustomersByStore} obejmuje pobranie aktywnych klientów przypisanych do konkretnego sklepu (StoreId = 1), wraz z informacjami o ich adresie, mieście i kraju. W wersji ORM wykorzystano łańcuchowe zagnieżdżenie metod \texttt{Include} w celu załadowania powiązanych encji. W podejściu SQL zastosowano klasyczne złączenia tabel, filtrację oraz sortowanie wyników po nazwisku i imieniu klienta.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectActiveCustomersByStore}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 2.52 & 2.13 \\
% 2 & 2.49 & 1.70 \\
% 3 & 2.67 & 1.79 \\
% 4 & 2.54 & 1.92 \\
% 5 & 2.55 & 1.85 \\
% 6 & 2.51 & 1.37 \\
% 7 & 2.50 & 1.31 \\
% 8 & 2.53 & 1.30 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 2.54 & 1.59 \\
% Odchylenie & 0.06 & 0.32 \\
% Min & 2.49 & 1.29 \\
% Max & 2.67 & 2.13 \\
% Zaalokowane bajty na operacje & 63088 & 10448 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- aktywni klienci danego sklepu z informacjami adresowymi}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT c.*, a."Address", city."City", country."Country"
% FROM "Customers" c
% JOIN "Addresses" a ON c."AddressId" = a."Id"
% JOIN "Cities" city ON a."CityId" = city."Id"
% JOIN "Countries" country ON city."CountryId" = country."Id"
% WHERE c."StoreId" = @StoreId AND c."IsActive" = true
% ORDER BY c."LastName", c."FirstName"
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT c."Id", c."AddressId", c."CreateDate", c."Email", c."FirstName", c."IsActive",
%        c."LastName", c."LastUpdate", c."StoreId", a."Id", a."Address", a."Address2", 
%        a."CityId", a."District", a."LastUpdate", a."Phone", a."PostCode", c0."Id",
%        c0."City", c0."CountryId", c0."LastUpdate", c1."Id", c1."Country", c1."LastUpdate"
% FROM "Customers" AS c
% INNER JOIN "Addresses" AS a ON c."AddressId" = a."Id"
% INNER JOIN "Cities" AS c0 ON a."CityId" = c0."Id"
% INNER JOIN "Countries" AS c1 ON c0."CountryId" = c1."Id"
% WHERE c."StoreId" = 1 AND c."IsActive"
% ORDER BY c."LastName", c."FirstName"
% \end{minted}
% \end{listing}

% \subsection{SelectActorsByFilmCount}
% Scenariusz \textit{SelectActorsByFilmCount} polega na wyszukaniu aktorów, którzy zagrali w co najmniej dziesięciu filmach. W podejściu ORM wykorzystano filtrację na podstawie liczby powiązanych encji \texttt{Films} oraz ich załadowanie metodą \texttt{Include}. W wersji SQL zastosowano złączenie tabeli \texttt{Actors} z tabelą relacyjną \texttt{FilmsActors}, grupowanie oraz warunek \texttt{HAVING} oparty na liczbie filmów przypisanych do każdego aktora.

% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectActorsByFilmCount}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 41.04 & 2.82 \\
% 2 & 38.89 & 2.89 \\
% 3 & 39.16 & 2.76 \\
% 4 & 40.07 & 2.76 \\
% 5 & 38.50 & 2.71 \\
% 6 & 39.06 & 2.81 \\
% 7 & 40.35 & 2.78 \\
% 8 & 40.21 & 2.77 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 39.59 & 2.79 \\
% Odchylenie & 0.85 & 0.05 \\
% Min & 38.50 & 2.71 \\
% Max & 41.04 & 2.89 \\
% Zaalokowane bajty na operacje & 53400 & 10280 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- aktorzy grający w co najmniej określonej liczbie filmów}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT a.*, COUNT(fa."FilmId") as FilmCount
% FROM "Actors" a
% JOIN "FilmsActors" fa ON a."Id" = fa."ActorId"
% GROUP BY a."Id"
% HAVING COUNT(fa."FilmId") >= @MinFilmCount
% ORDER BY COUNT(fa."FilmId") DESC
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT a."Id", a."FirstName", a."LastName", a."LastUpdate",
%        f1."ActorId", f1."FilmId", f1."ActorId1", f1."FilmId1", f1."LastUpdate"
% FROM "Actors" AS a
% LEFT JOIN "FilmsActors" AS f1 ON a."Id" = f1."ActorId"
% WHERE (
%     SELECT count(*)::int
%     FROM "FilmsActors" AS f
%     WHERE a."Id" = f."ActorId"
% ) >= 10
% ORDER BY (
%     SELECT count(*)::int
%     FROM "FilmsActors" AS f0
%     WHERE a."Id" = f0."ActorId"
% ) DESC, a."Id", f1."ActorId"
% \end{minted}
% \end{listing} 

% \subsection{SelectAllFilmsQueryBenchmark}
% Scenariusz \textit{SelectAllFilmsQueryBenchmark} wykonuje pełne zapytanie pobierające wszystkie rekordy z tabeli \texttt{Films}. W przypadku ORM zastosowano standardowe zapytanie LINQ z metodą \texttt{ToListAsync()}, natomiast podejście SQL opiera się na prostym zapytaniu \texttt{SELECT *} bez dodatkowej filtracji czy złączeń.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectAllFilmsQueryBenchmark}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 8.46 & 8.18 \\
% 2 & 9.00 & 6.26 \\
% 3 & 9.17 & 3.11 \\
% 4 & 15.75 & 5.16 \\
% 5 & 13.05 & 4.23 \\
% 6 & 8.07 & 3.94 \\
% 7 & 14.40 & 4.72 \\
% 8 & 14.04 & 4.16 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 11.73 & 4.87 \\
% Odchylenie & 3.00 & 1.52 \\
% Min & 8.07 & 3.11 \\
% Max & 15.75 & 8.18 \\
% Zaalokowane bajty na operacje & 573536 & 202344 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- pobranie wszystkich filmów}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT *
% FROM "Films"
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT f."Id", f."Description", f."FullText", f."LanguageId", f."LastUpdate", f."Length",
%        f."OriginalLanguageId", f."Rating", f."ReleaseYear", f."RentalDuration", f."RentalRate",
%        f."ReplacementCost", f."RevenueProjection", f."SpecialFeatures", f."Title"
% FROM "Films" AS f
% \end{minted}
% \end{listing}

% \subsection{SelectCustomerRentalHistory}
% Scenariusz \textit{SelectCustomerRentalHistory} polega na pobraniu historii wypożyczeń klienta o identyfikatorze 1, wraz z informacjami o wypożyczonych filmach oraz pracownikach obsługujących transakcje. W wersji ORM zastosowano filtrowanie i zagnieżdżone \texttt{Include}, aby pobrać powiązane dane z tabel \texttt{Inventory}, \texttt{Film} i \texttt{Staff}. W wersji SQL użyto klasycznych złączeń z odpowiednimi tabelami i sortowania według daty wypożyczenia malejąco.
% \begin{table}[H]

% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectCustomerRentalHistory}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 2.48 & 1.72 \\
% 2 & 2.27 & 1.72 \\
% 3 & 2.29 & 1.75 \\
% 4 & 2.24 & 1.86 \\
% 5 & 2.58 & 1.72 \\
% 6 & 3.35 & 1.86 \\
% 7 & 3.26 & 1.94 \\
% 8 & 3.28 & 1.99 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 2.83 & 1.83 \\
% Odchylenie & 0.49 & 0.10 \\
% Min & 2.24 & 1.72 \\
% Max & 3.35 & 1.99 \\
% Zaalokowane bajty na operacje & 65968 & 12496 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- wypożyczenia klienta z informacjami o filmie i pracowniku}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT r.*, f."Title", s."FirstName", s."LastName"
% FROM "Rentals" r
% JOIN "Inventories" i ON r."InventoryId" = i."Id"
% JOIN "Films" f ON i."FilmId" = f."Id"
% JOIN "Staff" s ON r."StaffId" = s."Id"
% WHERE r."CustomerId" = @CustomerId
% ORDER BY r."RentalStart" DESC
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT r."Id", r."CustomerId", r."InventoryId", r."LastUpdate", r."RentalEnd", r."RentalStart", 
%        r."StaffId", i."Id", i."FilmId", i."LastUpdate", i."StoreId", f."Id", f."Description", 
%        f."FullText", f."LanguageId", f."LastUpdate", f."Length", f."OriginalLanguageId", f."Rating",
%        f."ReleaseYear", f."RentalDuration", f."RentalRate", f."ReplacementCost", f."RevenueProjection",
%        f."SpecialFeatures", f."Title", s."Id", s."AddressId", s."Email", s."FirstName", s."IsActive", 
%        s."LastName", s."LastUpdate", s."Password", s."Picture", s."StoreId", s."Username"
% FROM "Rentals" AS r
% INNER JOIN "Inventories" AS i ON r."InventoryId" = i."Id"
% INNER JOIN "Films" AS f ON i."FilmId" = f."Id"
% INNER JOIN "Staff" AS s ON r."StaffId" = s."Id"
% WHERE r."CustomerId" = 1
% ORDER BY r."RentalStart" DESC
% \end{minted}
% \end{listing}

% \subsection{SelectCustomersFromTop3Countries}
% Scenariusz \textit{SelectCustomersFromTop3Countries} ma na celu pobranie klientów pochodzących z trzech krajów o największej liczbie klientów. W wersji ORM zastosowano zagnieżdżone zapytanie z \texttt{GroupBy}, \texttt{Take} oraz \texttt{Contains}, aby określić kraje o najwyższej liczbie klientów. W podejściu SQL wykorzystano podzapytanie z \texttt{GROUP BY}, \texttt{ORDER BY} i~\texttt{LIMIT}, aby wyłonić trzy najczęstsze wartości \texttt{CountryId}, a następnie filtrowano główne zapytanie względem tej listy.

% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectCustomersFromTop3Countries}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 27.31 & 37.28 \\
% 2 & 24.05 & 34.75 \\
% 3 & 24.74 & 32.62 \\
% 4 & 23.96 & 37.75 \\
% 5 & 24.99 & 40.09 \\
% 6 & 25.34 & 37.22 \\
% 7 & 26.02 & 37.21 \\
% 8 & 25.95 & 38.02 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 25.18 & 36.87 \\
% Odchylenie & 1.10 & 2.25 \\
% Min & 23.96 & 32.62 \\
% Max & 27.31 & 40.09 \\
% Zaalokowane bajty na operacje & 1059752 & 1454032 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- klienci z trzech krajów o największej liczbie klientów}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT cu.*
% FROM "Customers" cu
% JOIN "Addresses" a ON cu."AddressId" = a."Id"
% JOIN "Cities" ci ON a."CityId" = ci."Id"
% WHERE ci."CountryId" IN (
%     SELECT "CountryId"
%     FROM (
%         SELECT ci."CountryId", COUNT(*) AS CustomerCount
%         FROM "Customers" cu
%         JOIN "Addresses" a ON cu."AddressId" = a."Id"
%         JOIN "Cities" ci ON a."CityId" = ci."Id"
%         GROUP BY ci."CountryId"
%         ORDER BY COUNT(*) DESC
%         LIMIT 3
%     ) AS TopCountries
% )
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT c."Id", c."AddressId", c."CreateDate", c."Email", 
%        c."FirstName", c."IsActive", c."LastName", c."LastUpdate", c."StoreId"
% FROM "Customers" AS c
% INNER JOIN "Addresses" AS a ON c."AddressId" = a."Id"
% INNER JOIN "Cities" AS c0 ON a."CityId" = c0."Id"
% WHERE c0."CountryId" IN (
%     SELECT c2."CountryId"
%     FROM "Customers" AS c1
%     INNER JOIN "Addresses" AS a0 ON c1."AddressId" = a0."Id"
%     INNER JOIN "Cities" AS c2 ON a0."CityId" = c2."Id"
%     GROUP BY c2."CountryId"
%     ORDER BY count(*)::int DESC
%     LIMIT 3
% )
% \end{minted}
% \end{listing}

% \subsection{SelectCustomersWithOverdueRentals}
% Scenariusz \textit{SelectCustomersWithOverdueRentals} identyfikuje klientów posiadających zaległe wypożyczenia, czyli takie, które rozpoczęły się ponad siedem dni temu i nie zostały jeszcze zakończone. W podejściu ORM wykorzystano metodę \texttt{Any} do sprawdzenia warunku dla powiązanych wypożyczeń oraz \texttt{Include}, aby załadować ich szczegóły. W wersji SQL zastosowano złączenie tabel \texttt{Customers} i \texttt{Rentals} z odpowiednimi filtrami dotyczącymi braku daty zwrotu i~przekroczenia progu czasowego.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectCustomersWithOverdueRentals}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 87.04 & 29.73 \\
% 2 & 79.47 & 32.01 \\
% 3 & 82.51 & 36.27 \\
% 4 & 83.96 & 35.24 \\
% 5 & 83.28 & 28.53 \\
% 6 & 86.74 & 31.14 \\
% 7 & 87.61 & 30.46 \\
% 8 & 83.96 & 29.29 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 84.00 & 32.63 \\
% Odchylenie & 2.59 & 3.31 \\
% Min & 79.47 & 28.53 \\
% Max & 87.61 & 37.05 \\
% Zaalokowane bajty na operacje & 4852312 & 915448 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}


% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT DISTINCT c.*
% FROM "Customers" c
% JOIN "Rentals" r ON c."Id" = r."CustomerId"
% WHERE r."RentalEnd" IS NULL
%   AND r."RentalStart" < @OverdueThreshold
% \end{minted}
% \end{listing}


% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT c."Id", c."AddressId", c."CreateDate", c."Email", c."FirstName", c."IsActive", 
%        c."LastName", c."LastUpdate", c."StoreId", 
%        r0."Id", r0."CustomerId", r0."InventoryId", r0."LastUpdate", 
%        r0."RentalEnd", r0."RentalStart", r0."StaffId"
% FROM "Customers" AS c
% LEFT JOIN "Rentals" AS r0 ON c."Id" = r0."CustomerId"
% WHERE EXISTS (
%     SELECT 1
%     FROM "Rentals" AS r
%     WHERE c."Id" = r."CustomerId"
%       AND r."RentalEnd" IS NULL
%       AND r."RentalStart" < TIMESTAMPTZ '2025-06-05T22:06:43.753829Z'
% )
% ORDER BY c."Id"
% \end{minted}
% \end{listing}



% \subsection{SelectOverdueRentals}
% Scenariusz \textit{SelectOverdueRentals} wyszukuje wszystkie aktywne wypożyczenia, które przekroczyły deklarowany czas trwania filmu. W podejściu ORM zastosowano warunek logiczny na podstawie różnicy dni między datą rozpoczęcia wypożyczenia a bieżącą datą oraz porównanie z wartością \texttt{RentalDuration} powiązanego filmu. Wersja SQL opiera się na złączeniach z tabelami \texttt{Customers}, \texttt{Inventories} oraz \texttt{Films} i wykorzystuje funkcję \texttt{EXTRACT} do wyliczenia liczby dni.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectOverdueRentals}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 75.24 & 18.93  \\
% 2 & 62.95 & 18.98  \\
% 3 & 62.08 & 18.88  \\
% 4 & 79.41 & 18.04  \\
% 5 & 63.37 & 18.55  \\
% 6 & 62.19 & 20.93  \\
% 7 & 79.20 & 22.40  \\
% 8 & 64.49 & 21.43  \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia  & 69.04 & 19.77 \\
% Odchylenie & 7.48 & 1.59 \\
% Min & 62.08 & 18.04 \\
% Max & 79.41 & 22.40 \\
% Zaalokowane bajty na operacje & 2399368 & 66704 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- przeterminowane wypożyczenia}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT r.*, c."FirstName", c."LastName", f."Title", f."RentalDuration"
% FROM "Rentals" r
% JOIN "Customers" c ON r."CustomerId" = c."Id"
% JOIN "Inventories" i ON r."InventoryId" = i."Id"
% JOIN "Films" f ON i."FilmId" = f."Id"
% WHERE r."RentalEnd" IS NULL
%   AND EXTRACT(DAY FROM (NOW() - r."RentalStart")) > f."RentalDuration"
% ORDER BY r."RentalStart"
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT r."Id", r."CustomerId", r."InventoryId", r."LastUpdate", r."RentalEnd", r."RentalStart", 
%        r."StaffId", c."Id", c."AddressId", c."CreateDate", c."Email", c."FirstName", c."IsActive", 
%        c."LastName", c."LastUpdate", c."StoreId", i."Id", i."FilmId", i."LastUpdate", i."StoreId",
%        f."Id", f."Description", f."FullText", f."LanguageId", f."LastUpdate", f."Length", 
%        f."OriginalLanguageId", f."Rating", f."ReleaseYear", f."RentalDuration", f."RentalRate", 
%        f."ReplacementCost", f."RevenueProjection", f."SpecialFeatures", f."Title"
% FROM "Rentals" AS r
% INNER JOIN "Inventories" AS i ON r."InventoryId" = i."Id"
% INNER JOIN "Films" AS f ON i."FilmId" = f."Id"
% INNER JOIN "Customers" AS c ON r."CustomerId" = c."Id"
% WHERE r."RentalEnd" IS NULL
%   AND floor(date_part('day', r."RentalStart" - now()))::int > f."RentalDuration"
% ORDER BY r."RentalStart"
% \end{minted}
% \end{listing}


% \subsection{UpdateAddressesInCityBenchmark}
% Scenariusz \textit{UpdateAddressesInCityBenchmark} aktualizuje pole \texttt{District} dla wszystkich adresów znajdujących się w~mieście o nazwie \texttt{Warsaw}. W wersji ORM rekordy są najpierw pobierane do pamięci, a następnie modyfikowane i zapisywane przy użyciu \texttt{SaveChangesAsync()}. Podejście SQL korzysta z instrukcji \texttt{UPDATE} z podzapytaniem wybierającym identyfikatory miasta spełniające warunek.
% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{UpdateAddressesInCityBenchmark}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 3.20 & 1.65 \\
% 2 & 3.01 & 1.56 \\
% 3 & 3.15 & 1.55 \\
% 4 & 2.72 & 1.75 \\
% 5 & 2.68 & 1.58 \\
% 6 & 2.56 & 1.55 \\
% 7 & 2.80 & 1.74 \\
% 8 & 3.01 & 1.57 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 2.88 & 1.62 \\
% Odchylenie & 0.21 & 0.08 \\
% Min & 2.56 & 1.55 \\
% Max & 3.20 & 1.75 \\
% Zaalokowane bajty na operacje & 87616 & 9536 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- aktualizacja dzielnicy dla adresów w Warszawie}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% UPDATE "Addresses"
% SET "District" = 'Updated District'
% WHERE "CityId" IN (
%     SELECT "Id" FROM "Cities" WHERE "City" = 'Warsaw'
% )
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% UPDATE "Addresses" SET "District" = @p0
%       WHERE "Id" = @p1;
% \end{minted}
% \end{listing}

% \subsection{SelectInventoryByStore}
% Scenariusz \textit{SelectInventoryByStore} polega na pobraniu wszystkich rekordów inwentarza przypisanych do konkretnego sklepu (StoreId = 1). W podejściu ORM wykorzystano filtrowanie za pomocą metody \texttt{Where} i asynchroniczne wykonanie zapytania. W wersji SQL zastosowano prostą instrukcję \texttt{SELECT} z warunkiem \texttt{WHERE} i parametrem przekazywanym do zapytania.

% \begin{table}[H]
% \centering
% \caption{Porównanie ORM i SQL dla scenariusza \textit{SelectInventoryByStore}}
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Pojedyncze pomiary}

% \begin{tabular}{@{}c r r@{}}
% \toprule
% \textbf{L.p} & \textbf{ORM [ms]} & \textbf{SQL [ms]} \\
% \midrule
% 1 & 2.20 & 2.63 \\
% 2 & 2.23 & 2.67 \\
% 3 & 2.12 & 2.67 \\
% 4 & 3.31 & 2.59 \\
% 5 & 3.33 & 2.57 \\
% 6 & 3.35 & 2.59 \\
% 7 & 3.37 & 2.48 \\
% 8 & 3.31 & 2.29 \\
% \bottomrule
% \end{tabular}
% \end{minipage}
% \hfill
% \begin{minipage}{0.48\textwidth}
% \centering
% \small
% \textbf{Statystyki (ms)}

% \begin{tabular}{@{}l r r@{}}
% \toprule
%  & \textbf{ORM} & \textbf{SQL} \\
% \midrule
% Średnia & 2.90 & 2.55 \\
% Odchylenie & 0.58 & 0.13 \\
% Min & 2.12 & 2.29 \\
% Max & 3.40 & 2.67 \\
% Bytes Allocated Per Operation & 167392 & 100848 \\
% \bottomrule
% \end{tabular}
% \end{minipage}

% \end{table}

% \begin{listing}[H]
% \caption{Zapytanie SQL (Raw) -- wszystkie pozycje magazynowe w danym sklepie}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT *
% FROM "Inventories"
% WHERE "StoreId" = @StoreId
% \end{minted}
% \end{listing}

% \begin{listing}[H]
% \caption{Zapytanie ORM (wygenerowane przez narzędzie ORM)}
% \begin{minted}[fontsize=\small, bgcolor=gray!5]{sql}
% SELECT i."Id", i."FilmId", i."LastUpdate", i."StoreId"
% FROM "Inventories" AS i
% WHERE i."StoreId" = 1
% \end{minted}
% \end{listing}